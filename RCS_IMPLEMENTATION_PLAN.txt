================================================================================
                        RCS 구현 계획 상세 문서
================================================================================

작성일: 2025-10-15
프로젝트: MTS Message - RCS 메시지 발송 기능
예상 기간: 4주
우선순위: 3순위 (카카오, 네이버 이후)

================================================================================
목차
================================================================================
0. 시작하기 전 필수 이해사항
1. RCS 개요 및 특징
2. 사전 준비사항 (RCS Biz Center)
3. 데이터베이스 설계
4. API 엔드포인트 설계
5. 주요 기능 구현
6. 주차별 구현 계획
7. 테스트 시나리오
8. 트러블슈팅 가이드

================================================================================
0. 시작하기 전 필수 이해사항
================================================================================

【중요】RCS는 카카오/네이버와 완전히 다른 플랫폼입니다.

┌─────────────────────────────────────────────────────────────────┐
│ RCS 플랫폼 구조                                                   │
├─────────────────────────────────────────────────────────────────┤
│ 운영 주체: KT, SKT, LG U+ 3사 공동 운영                          │
│ 웹사이트: https://www.rcsbizcenter.com                           │
│ 승인 기간: 브랜드 승인 1-2주 소요                                 │
│ 기술 방식: MaaP(Messaging as a Platform) 표준                    │
│ 대행사 지정: "솔라피 주식회사" 필수 지정                          │
└─────────────────────────────────────────────────────────────────┘

【RCS vs 기존 메시지 비교】
┌──────────┬─────────────────────────────────────────────────┐
│ 항목     │ RCS                                             │
├──────────┼─────────────────────────────────────────────────┤
│ 텍스트   │ 최대 1,300자 (SMS 80자, MMS 2,000자 대비)       │
│ 이미지   │ 고화질 이미지 지원 (최대 1.5MB)                  │
│ 버튼     │ 최대 2개 (URL/전화/공유 등)                      │
│ 슬라이드 │ 캐러셀 형태 지원 (최대 6개)                      │
│ 템플릿   │ 승인 필요 (관리자 승인 후 사용)                  │
│ 발신번호 │ 브랜드에 등록된 번호만 사용                      │
│ 비용     │ SMS/MMS 대비 약간 높음                           │
└──────────┴─────────────────────────────────────────────────┘

【발송 프로세스】
1. RCS Biz Center 가입
2. 브랜드 개설 신청 (사업자 정보 필요)
3. 브랜드 승인 대기 (1-2주)
4. "솔라피 주식회사" 대행사 지정
5. 챗봇 ID 생성 및 발신번호 등록
6. 템플릿 작성 및 승인 신청
7. 승인된 템플릿으로 발송

================================================================================
1. RCS 개요 및 특징
================================================================================

1.1 RCS(Rich Communication Services)란?
----------------------------------------
- SMS/MMS를 대체하는 차세대 메시징 서비스
- 별도 앱 설치 없이 기본 메시지 앱에서 작동
- 텍스트, 이미지, 동영상, 버튼 등 리치 컨텐츠 지원
- 브랜드 인증을 통한 신뢰성 제공

1.2 RCS 메시지 유형
----------------------------------------
┌─────────────┬──────────────────────────────────────────┐
│ 유형        │ 설명                                      │
├─────────────┼──────────────────────────────────────────┤
│ SMS형       │ 텍스트 + 버튼 (기본형)                    │
│ LMS형       │ 긴 텍스트 + 이미지 + 버튼                 │
│ MMS형       │ 이미지 중심 + 텍스트 + 버튼               │
│ 슬라이드형  │ 캐러셀 형태 (최대 6개 카드)               │
└─────────────┴──────────────────────────────────────────┘

1.3 RCS API 제공자
----------------------------------------
본 프로젝트에서는 "솔라피(Solapi)" 대행사 API 사용 예정
- API 문서: https://docs.solapi.com
- Chatbot ID와 Message Base ID 필요
- REST API 방식 (JSON)

================================================================================
2. 사전 준비사항 (RCS Biz Center)
================================================================================

2.1 RCS Biz Center 가입 및 브랜드 개설
----------------------------------------
【Step 1】 RCS Biz Center 가입
- URL: https://www.rcsbizcenter.com
- 기업 회원가입 (사업자등록번호 필요)
- 담당자 정보 입력

【Step 2】 브랜드 개설 신청
- 로그인 → 우측 상단 "기업 대시보드" 클릭
- "브랜드 개설" 버튼 클릭
- 필수 정보 입력:
  * 브랜드명
  * 브랜드 로고 (200x200px)
  * 대표 전화번호
  * 회사 주소
  * 사업자등록증 첨부

【Step 3】 브랜드 승인 대기
- 승인 기간: 영업일 기준 1-2주
- 승인 완료 시 이메일 알림
- RCS Biz Center에서 승인 상태 확인 가능

2.2 대행사 지정 (필수)
----------------------------------------
【중요】 브랜드 승인 후 반드시 "솔라피 주식회사"를 대행사로 지정해야 함

【대행사 지정 방법】
1. RCS Biz Center 로그인
2. 우측 상단 "기업 대시보드" 클릭
3. 연동할 브랜드 선택
4. 좌측 메뉴 "브랜드 운영 관리" 클릭
5. "대행사 운영권한 부여" 버튼 클릭
6. 대행사 검색 → "솔라피 주식회사" 선택
7. 권한 부여 완료

【선택사항】 양방향 메시지 사용 시
- "lguplus"도 함께 대행사로 지정
- 고객의 답장을 받을 수 있음

2.3 챗봇 ID 및 발신번호 등록
----------------------------------------
【챗봇 ID 생성】
1. 브랜드 대시보드 → "챗봇 관리"
2. "챗봇 생성" 버튼 클릭
3. 챗봇 이름 입력 (예: "마케팅 알림")
4. 생성된 Chatbot ID 복사 → 환경변수에 저장

【발신번호 등록】
1. "대화방 목록" → "대화방 등록"
2. 발신번호 입력 (통신서비스 가입증명서 필요)
3. 관리자 승인 대기 (영업일 기준 1-3일)
4. 승인 완료 시 Message Base ID 발급

2.4 환경변수 설정
----------------------------------------
브랜드 승인 및 대행사 지정 완료 후 .env.local에 추가:

```env
# ===== RCS 메시지 발송 =====
RCS_CHATBOT_ID=your_chatbot_id                  # RCS Biz Center에서 발급
RCS_MESSAGE_BASE_ID=your_message_base_id        # 대화방 승인 후 발급
SOLAPI_API_KEY=your_solapi_api_key              # 솔라피 API 키
SOLAPI_API_SECRET=your_solapi_api_secret        # 솔라피 시크릿 키
```

【참고 문서】
- RCS Biz Center 가이드: https://www.rcsbizcenter.com/guide
- 솔라피 RCS 문서: https://docs.solapi.com/rcs

================================================================================
3. 데이터베이스 설계
================================================================================

3.1 RCS 브랜드 테이블 (rcs_brands)
----------------------------------------
브랜드 정보 및 연동 상태 관리

CREATE TABLE rcs_brands (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,

  -- 브랜드 정보
  brand_name VARCHAR(100) NOT NULL,
  brand_id VARCHAR(100) UNIQUE NOT NULL,          -- RCS Biz Center 브랜드 ID
  chatbot_id VARCHAR(100) NOT NULL,               -- 챗봇 ID
  message_base_id VARCHAR(100) NOT NULL,          -- Message Base ID

  -- 브랜드 상태
  status VARCHAR(20) NOT NULL DEFAULT 'pending',  -- pending/active/suspended
  approval_date TIMESTAMP,                        -- 승인 완료일

  -- 브랜드 설정
  logo_url TEXT,                                  -- 브랜드 로고 URL
  description TEXT,                               -- 브랜드 설명
  company_phone VARCHAR(20),                      -- 대표 전화번호
  company_address TEXT,                           -- 회사 주소

  -- 메타데이터
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_rcs_brands_user ON rcs_brands(user_id);
CREATE INDEX idx_rcs_brands_status ON rcs_brands(status);

3.2 RCS 템플릿 테이블 (rcs_templates)
----------------------------------------
RCS 메시지 템플릿 관리

CREATE TABLE rcs_templates (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  brand_id UUID NOT NULL REFERENCES rcs_brands(id) ON DELETE CASCADE,

  -- 템플릿 정보
  template_name VARCHAR(100) NOT NULL,
  template_id VARCHAR(100),                       -- RCS 승인 템플릿 ID
  template_type VARCHAR(20) NOT NULL,             -- sms/lms/mms/slide

  -- 템플릿 상태
  status VARCHAR(20) NOT NULL DEFAULT 'pending',  -- pending/approved/rejected
  approval_date TIMESTAMP,                        -- 승인 완료일
  rejection_reason TEXT,                          -- 반려 사유

  -- 메시지 내용
  message_content TEXT NOT NULL,                  -- 메시지 본문 (변수: #{변수명})
  image_url TEXT,                                 -- 이미지 URL (LMS/MMS형)

  -- 버튼 설정 (최대 2개)
  buttons JSONB DEFAULT '[]',
  -- 예시: [
  --   { "type": "url", "name": "자세히 보기", "url": "https://example.com" },
  --   { "type": "phone", "name": "전화하기", "number": "02-1234-5678" }
  -- ]

  -- 슬라이드 설정 (슬라이드형 전용)
  slides JSONB DEFAULT '[]',
  -- 예시: [
  --   { "title": "제품1", "description": "설명", "image": "url1", "buttons": [...] },
  --   { "title": "제품2", "description": "설명", "image": "url2", "buttons": [...] }
  -- ]

  -- 메타데이터
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_rcs_templates_user ON rcs_templates(user_id);
CREATE INDEX idx_rcs_templates_brand ON rcs_templates(brand_id);
CREATE INDEX idx_rcs_templates_status ON rcs_templates(status);

3.3 RCS 메시지 발송 로그 (rcs_message_logs)
----------------------------------------
발송 이력 및 결과 추적

CREATE TABLE rcs_message_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  template_id UUID REFERENCES rcs_templates(id) ON DELETE SET NULL,
  brand_id UUID NOT NULL REFERENCES rcs_brands(id) ON DELETE CASCADE,

  -- 수신자 정보
  recipient_phone VARCHAR(20) NOT NULL,
  recipient_name VARCHAR(100),

  -- 발송 내용
  message_type VARCHAR(20) NOT NULL,              -- sms/lms/mms/slide
  message_content TEXT NOT NULL,                  -- 치환 완료된 메시지
  image_url TEXT,
  buttons JSONB,
  slides JSONB,

  -- 발송 결과
  status VARCHAR(20) NOT NULL DEFAULT 'pending',  -- pending/sent/failed/delivered
  sent_at TIMESTAMP,
  delivered_at TIMESTAMP,
  failed_reason TEXT,

  -- 외부 API 응답
  message_id VARCHAR(100),                        -- 솔라피 메시지 ID
  api_response JSONB,

  -- 비용
  cost_credits INTEGER DEFAULT 0,

  -- 메타데이터
  created_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_rcs_logs_user ON rcs_message_logs(user_id);
CREATE INDEX idx_rcs_logs_template ON rcs_message_logs(template_id);
CREATE INDEX idx_rcs_logs_status ON rcs_message_logs(status);
CREATE INDEX idx_rcs_logs_created ON rcs_message_logs(created_at DESC);

================================================================================
4. API 엔드포인트 설계
================================================================================

4.1 브랜드 관리 API
----------------------------------------

【GET /api/rcs/brands】
- 기능: 연동된 RCS 브랜드 목록 조회
- 응답:
  {
    "brands": [
      {
        "id": "uuid",
        "brand_name": "우리회사",
        "brand_id": "BRAND123",
        "status": "active",
        "chatbot_id": "CHATBOT123",
        "logo_url": "https://..."
      }
    ]
  }

【POST /api/rcs/brands】
- 기능: 새 브랜드 연동 (RCS Biz Center 승인 완료 후)
- 요청:
  {
    "brand_name": "우리회사",
    "brand_id": "BRAND123",
    "chatbot_id": "CHATBOT123",
    "message_base_id": "MB123",
    "logo_url": "https://...",
    "company_phone": "02-1234-5678"
  }
- 응답:
  {
    "success": true,
    "brand_id": "uuid"
  }

【DELETE /api/rcs/brands/[id]】
- 기능: 브랜드 연동 해제
- 응답:
  {
    "success": true,
    "message": "브랜드 연동이 해제되었습니다."
  }

4.2 템플릿 관리 API
----------------------------------------

【GET /api/rcs/templates】
- 기능: 브랜드별 템플릿 목록 조회
- 쿼리 파라미터: ?brand_id=uuid&status=approved
- 응답:
  {
    "templates": [
      {
        "id": "uuid",
        "template_name": "신상품 알림",
        "template_type": "mms",
        "status": "approved",
        "message_content": "안녕하세요 #{고객명}님...",
        "image_url": "https://...",
        "buttons": [...]
      }
    ]
  }

【POST /api/rcs/templates】
- 기능: 새 템플릿 생성 (승인 신청)
- 요청:
  {
    "brand_id": "uuid",
    "template_name": "신상품 알림",
    "template_type": "mms",
    "message_content": "안녕하세요 #{고객명}님, 신상품이 출시되었습니다.",
    "image_url": "https://storage.../image.jpg",
    "buttons": [
      { "type": "url", "name": "구매하기", "url": "https://shop.com" }
    ]
  }
- 응답:
  {
    "success": true,
    "template_id": "uuid",
    "message": "템플릿이 생성되었습니다. 승인을 기다려주세요."
  }

【PUT /api/rcs/templates/[id]】
- 기능: 템플릿 수정 (재승인 필요)
- 요청: POST와 동일한 구조
- 응답:
  {
    "success": true,
    "message": "템플릿이 수정되었습니다. 재승인을 기다려주세요."
  }

【DELETE /api/rcs/templates/[id]】
- 기능: 템플릿 삭제
- 응답:
  {
    "success": true,
    "message": "템플릿이 삭제되었습니다."
  }

4.3 메시지 발송 API
----------------------------------------

【POST /api/rcs/send】
- 기능: RCS 메시지 발송
- 요청:
  {
    "template_id": "uuid",
    "recipients": [
      {
        "phone_number": "01012345678",
        "name": "홍길동",
        "variables": {
          "고객명": "홍길동",
          "상품명": "노트북",
          "할인가": "990,000원"
        }
      }
    ],
    "send_immediately": true,
    "scheduled_at": null
  }
- 응답:
  {
    "success": true,
    "sent_count": 1,
    "failed_count": 0,
    "message_ids": ["uuid1", "uuid2"]
  }

【POST /api/rcs/send/preview】
- 기능: 메시지 미리보기 (변수 치환 결과)
- 요청:
  {
    "template_id": "uuid",
    "variables": {
      "고객명": "홍길동",
      "상품명": "노트북"
    }
  }
- 응답:
  {
    "message_content": "안녕하세요 홍길동님, 노트북이 출시되었습니다.",
    "image_url": "https://...",
    "buttons": [...]
  }

4.4 발송 이력 조회 API
----------------------------------------

【GET /api/rcs/logs】
- 기능: 발송 이력 조회
- 쿼리 파라미터:
  * ?page=1&limit=20
  * &status=sent
  * &start_date=2024-01-01
  * &end_date=2024-12-31
- 응답:
  {
    "logs": [
      {
        "id": "uuid",
        "recipient_phone": "010-1234-5678",
        "message_type": "mms",
        "status": "delivered",
        "sent_at": "2024-01-15T10:30:00Z",
        "cost_credits": 15
      }
    ],
    "total": 100,
    "page": 1,
    "limit": 20
  }

================================================================================
5. 주요 기능 구현
================================================================================

5.1 브랜드 연동 구현
----------------------------------------
파일: src/app/api/rcs/brands/route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';
import { verifyToken } from '@/lib/auth';

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);

// GET: 브랜드 목록 조회
export async function GET(request: NextRequest) {
  try {
    const token = request.headers.get('Authorization')?.replace('Bearer ', '');
    if (!token) {
      return NextResponse.json({ error: '인증 토큰이 필요합니다.' }, { status: 401 });
    }

    const decoded = verifyToken(token);
    const userId = decoded.userId;

    const { data: brands, error } = await supabase
      .from('rcs_brands')
      .select('*')
      .eq('user_id', userId)
      .order('created_at', { ascending: false });

    if (error) throw error;

    return NextResponse.json({ brands });
  } catch (error: any) {
    console.error('브랜드 조회 오류:', error);
    return NextResponse.json(
      { error: error.message || '브랜드 조회에 실패했습니다.' },
      { status: 500 }
    );
  }
}

// POST: 새 브랜드 연동
export async function POST(request: NextRequest) {
  try {
    const token = request.headers.get('Authorization')?.replace('Bearer ', '');
    if (!token) {
      return NextResponse.json({ error: '인증 토큰이 필요합니다.' }, { status: 401 });
    }

    const decoded = verifyToken(token);
    const userId = decoded.userId;

    const body = await request.json();
    const {
      brand_name,
      brand_id,
      chatbot_id,
      message_base_id,
      logo_url,
      company_phone,
      company_address,
      description
    } = body;

    // 필수 필드 검증
    if (!brand_name || !brand_id || !chatbot_id || !message_base_id) {
      return NextResponse.json(
        { error: '필수 필드를 모두 입력해주세요.' },
        { status: 400 }
      );
    }

    // 중복 확인
    const { data: existing } = await supabase
      .from('rcs_brands')
      .select('id')
      .eq('brand_id', brand_id)
      .single();

    if (existing) {
      return NextResponse.json(
        { error: '이미 연동된 브랜드입니다.' },
        { status: 400 }
      );
    }

    // 브랜드 생성
    const { data: brand, error } = await supabase
      .from('rcs_brands')
      .insert({
        user_id: userId,
        brand_name,
        brand_id,
        chatbot_id,
        message_base_id,
        logo_url,
        company_phone,
        company_address,
        description,
        status: 'active',
        approval_date: new Date().toISOString()
      })
      .select()
      .single();

    if (error) throw error;

    return NextResponse.json({
      success: true,
      brand_id: brand.id,
      message: '브랜드가 성공적으로 연동되었습니다.'
    });
  } catch (error: any) {
    console.error('브랜드 연동 오류:', error);
    return NextResponse.json(
      { error: error.message || '브랜드 연동에 실패했습니다.' },
      { status: 500 }
    );
  }
}
```

5.2 템플릿 생성 구현
----------------------------------------
파일: src/app/api/rcs/templates/route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';
import { verifyToken } from '@/lib/auth';

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);

// POST: 템플릿 생성
export async function POST(request: NextRequest) {
  try {
    const token = request.headers.get('Authorization')?.replace('Bearer ', '');
    if (!token) {
      return NextResponse.json({ error: '인증 토큰이 필요합니다.' }, { status: 401 });
    }

    const decoded = verifyToken(token);
    const userId = decoded.userId;

    const body = await request.json();
    const {
      brand_id,
      template_name,
      template_type,
      message_content,
      image_url,
      buttons,
      slides
    } = body;

    // 필수 필드 검증
    if (!brand_id || !template_name || !template_type || !message_content) {
      return NextResponse.json(
        { error: '필수 필드를 모두 입력해주세요.' },
        { status: 400 }
      );
    }

    // 템플릿 타입 검증
    const validTypes = ['sms', 'lms', 'mms', 'slide'];
    if (!validTypes.includes(template_type)) {
      return NextResponse.json(
        { error: '유효하지 않은 템플릿 타입입니다.' },
        { status: 400 }
      );
    }

    // 버튼 개수 검증 (최대 2개)
    if (buttons && buttons.length > 2) {
      return NextResponse.json(
        { error: 'RCS 버튼은 최대 2개까지 가능합니다.' },
        { status: 400 }
      );
    }

    // 슬라이드 개수 검증 (최대 6개)
    if (template_type === 'slide' && slides && slides.length > 6) {
      return NextResponse.json(
        { error: 'RCS 슬라이드는 최대 6개까지 가능합니다.' },
        { status: 400 }
      );
    }

    // 템플릿 생성
    const { data: template, error } = await supabase
      .from('rcs_templates')
      .insert({
        user_id: userId,
        brand_id,
        template_name,
        template_type,
        message_content,
        image_url: image_url || null,
        buttons: buttons || [],
        slides: slides || [],
        status: 'pending' // 승인 대기
      })
      .select()
      .single();

    if (error) throw error;

    return NextResponse.json({
      success: true,
      template_id: template.id,
      message: '템플릿이 생성되었습니다. RCS Biz Center에서 승인을 기다려주세요.'
    });
  } catch (error: any) {
    console.error('템플릿 생성 오류:', error);
    return NextResponse.json(
      { error: error.message || '템플릿 생성에 실패했습니다.' },
      { status: 500 }
    );
  }
}
```

5.3 RCS 메시지 발송 구현 (솔라피 API)
----------------------------------------
파일: src/app/api/rcs/send/route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';
import { verifyToken } from '@/lib/auth';
import crypto from 'crypto';

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);

// 솔라피 HMAC 서명 생성
function generateSolapiSignature(timestamp: string): string {
  const message = timestamp + process.env.SOLAPI_API_KEY!;
  const hmac = crypto.createHmac('sha256', process.env.SOLAPI_API_SECRET!);
  return hmac.update(message).digest('hex');
}

// 변수 치환 함수
function replaceVariables(content: string, variables: Record<string, string>): string {
  let result = content;
  for (const [key, value] of Object.entries(variables)) {
    const regex = new RegExp(`#{${key}}`, 'g');
    result = result.replace(regex, value);
  }
  return result;
}

// POST: RCS 메시지 발송
export async function POST(request: NextRequest) {
  try {
    const token = request.headers.get('Authorization')?.replace('Bearer ', '');
    if (!token) {
      return NextResponse.json({ error: '인증 토큰이 필요합니다.' }, { status: 401 });
    }

    const decoded = verifyToken(token);
    const userId = decoded.userId;

    const body = await request.json();
    const { template_id, recipients } = body;

    if (!template_id || !recipients || recipients.length === 0) {
      return NextResponse.json(
        { error: '템플릿과 수신자를 지정해주세요.' },
        { status: 400 }
      );
    }

    // 템플릿 조회
    const { data: template, error: templateError } = await supabase
      .from('rcs_templates')
      .select('*, rcs_brands(*)')
      .eq('id', template_id)
      .eq('user_id', userId)
      .single();

    if (templateError || !template) {
      return NextResponse.json({ error: '템플릿을 찾을 수 없습니다.' }, { status: 404 });
    }

    if (template.status !== 'approved') {
      return NextResponse.json(
        { error: '승인된 템플릿만 발송할 수 있습니다.' },
        { status: 400 }
      );
    }

    // 잔액 확인
    const { data: balance } = await supabase
      .from('users')
      .select('balance')
      .eq('id', userId)
      .single();

    const costPerMessage = 15; // RCS 1건당 비용 (예시)
    const totalCost = recipients.length * costPerMessage;

    if (balance && balance.balance < totalCost) {
      return NextResponse.json(
        { error: '잔액이 부족합니다.' },
        { status: 400 }
      );
    }

    // 발송 처리
    let sentCount = 0;
    let failedCount = 0;
    const messageIds: string[] = [];

    for (const recipient of recipients) {
      try {
        // 변수 치환
        const finalContent = replaceVariables(
          template.message_content,
          recipient.variables || {}
        );

        // 솔라피 API 호출
        const timestamp = Date.now().toString();
        const signature = generateSolapiSignature(timestamp);

        const solapiPayload = {
          messages: [
            {
              to: recipient.phone_number.replace(/-/g, ''),
              from: template.rcs_brands.message_base_id,
              text: finalContent,
              type: template.template_type === 'slide' ? 'MMS' : template.template_type.toUpperCase(),
              ...(template.image_url && { imageUrl: template.image_url }),
              ...(template.buttons && template.buttons.length > 0 && {
                buttons: template.buttons
              }),
              ...(template.slides && template.slides.length > 0 && {
                carousel: template.slides
              })
            }
          ]
        };

        const solapiResponse = await fetch('https://api.solapi.com/messages/v4/send', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `HMAC-SHA256 apiKey=${process.env.SOLAPI_API_KEY}, date=${timestamp}, signature=${signature}`
          },
          body: JSON.stringify(solapiPayload)
        });

        const solapiData = await solapiResponse.json();

        if (solapiResponse.ok) {
          // 발송 로그 저장
          const { data: log } = await supabase
            .from('rcs_message_logs')
            .insert({
              user_id: userId,
              template_id: template.id,
              brand_id: template.brand_id,
              recipient_phone: recipient.phone_number,
              recipient_name: recipient.name || null,
              message_type: template.template_type,
              message_content: finalContent,
              image_url: template.image_url,
              buttons: template.buttons,
              slides: template.slides,
              status: 'sent',
              sent_at: new Date().toISOString(),
              message_id: solapiData.messageId,
              api_response: solapiData,
              cost_credits: costPerMessage
            })
            .select()
            .single();

          sentCount++;
          if (log) messageIds.push(log.id);
        } else {
          throw new Error(solapiData.message || 'RCS 발송 실패');
        }
      } catch (error: any) {
        console.error('개별 발송 오류:', error);

        // 실패 로그 저장
        await supabase.from('rcs_message_logs').insert({
          user_id: userId,
          template_id: template.id,
          brand_id: template.brand_id,
          recipient_phone: recipient.phone_number,
          recipient_name: recipient.name || null,
          message_type: template.template_type,
          message_content: replaceVariables(template.message_content, recipient.variables || {}),
          status: 'failed',
          failed_reason: error.message,
          cost_credits: 0
        });

        failedCount++;
      }
    }

    // 잔액 차감
    if (sentCount > 0) {
      await supabase
        .from('users')
        .update({ balance: balance!.balance - (sentCount * costPerMessage) })
        .eq('id', userId);

      // 거래 내역 저장
      await supabase.from('transactions').insert({
        user_id: userId,
        type: 'usage',
        amount: -(sentCount * costPerMessage),
        description: `RCS 메시지 ${sentCount}건 발송`,
        status: 'completed'
      });
    }

    return NextResponse.json({
      success: true,
      sent_count: sentCount,
      failed_count: failedCount,
      message_ids: messageIds,
      message: `${sentCount}건 발송 성공, ${failedCount}건 실패`
    });
  } catch (error: any) {
    console.error('RCS 발송 오류:', error);
    return NextResponse.json(
      { error: error.message || 'RCS 발송에 실패했습니다.' },
      { status: 500 }
    );
  }
}
```

5.4 이미지 업로드 구현
----------------------------------------
파일: src/app/api/rcs/upload-image/route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';
import { verifyToken } from '@/lib/auth';

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);

export async function POST(request: NextRequest) {
  try {
    const token = request.headers.get('Authorization')?.replace('Bearer ', '');
    if (!token) {
      return NextResponse.json({ error: '인증 토큰이 필요합니다.' }, { status: 401 });
    }

    const decoded = verifyToken(token);
    const userId = decoded.userId;

    const formData = await request.formData();
    const file = formData.get('file') as File;

    if (!file) {
      return NextResponse.json({ error: '파일을 선택해주세요.' }, { status: 400 });
    }

    // 파일 크기 검증 (최대 1.5MB)
    const maxSize = 1.5 * 1024 * 1024;
    if (file.size > maxSize) {
      return NextResponse.json(
        { error: 'RCS 이미지는 최대 1.5MB까지 업로드 가능합니다.' },
        { status: 400 }
      );
    }

    // 파일 타입 검증
    const allowedTypes = ['image/jpeg', 'image/png', 'image/jpg'];
    if (!allowedTypes.includes(file.type)) {
      return NextResponse.json(
        { error: 'JPG, PNG 형식만 업로드 가능합니다.' },
        { status: 400 }
      );
    }

    // 파일명 생성
    const timestamp = Date.now();
    const randomString = Math.random().toString(36).substring(2, 8);
    const extension = file.name.split('.').pop();
    const fileName = `${userId}/${timestamp}-${randomString}.${extension}`;

    // Supabase Storage 업로드
    const arrayBuffer = await file.arrayBuffer();
    const buffer = Buffer.from(arrayBuffer);

    const { data, error } = await supabase.storage
      .from('rcs-images')
      .upload(fileName, buffer, {
        contentType: file.type,
        upsert: false
      });

    if (error) throw error;

    // Public URL 생성
    const { data: publicUrlData } = supabase.storage
      .from('rcs-images')
      .getPublicUrl(fileName);

    return NextResponse.json({
      success: true,
      url: publicUrlData.publicUrl,
      file_name: fileName
    });
  } catch (error: any) {
    console.error('이미지 업로드 오류:', error);
    return NextResponse.json(
      { error: error.message || '이미지 업로드에 실패했습니다.' },
      { status: 500 }
    );
  }
}
```

================================================================================
6. 주차별 구현 계획
================================================================================

┌─────────┬────────────────────────────────────────────────────┐
│ 주차    │ 작업 내용                                           │
├─────────┼────────────────────────────────────────────────────┤
│ Week 1  │ 브랜드 연동 및 기본 설정                            │
│         │ - RCS Biz Center 가입 및 브랜드 개설 신청           │
│         │ - 데이터베이스 테이블 생성                          │
│         │ - 브랜드 관리 API 구현                              │
│         │ - 브랜드 목록 UI 연동                               │
│         │ - 환경변수 설정 및 테스트                           │
├─────────┼────────────────────────────────────────────────────┤
│ Week 2  │ 템플릿 관리 및 승인 프로세스                        │
│         │ - 템플릿 CRUD API 구현                              │
│         │ - 템플릿 목록/생성 UI 연동                          │
│         │ - 이미지 업로드 기능 (Supabase Storage)             │
│         │ - 버튼 설정 UI (최대 2개)                           │
│         │ - 승인 상태 관리 로직                               │
├─────────┼────────────────────────────────────────────────────┤
│ Week 3  │ 메시지 발송 기능 (SMS/LMS/MMS형)                    │
│         │ - 솔라피 API 연동                                   │
│         │ - HMAC 서명 생성 로직                               │
│         │ - 변수 치환 로직 구현                               │
│         │ - 메시지 발송 API 구현                              │
│         │ - 발송 UI 연동 (RcsMessageContent.tsx)              │
│         │ - 발송 로그 저장 및 조회                            │
├─────────┼────────────────────────────────────────────────────┤
│ Week 4  │ 슬라이드형 메시지 및 최종 테스트                    │
│         │ - 슬라이드(캐러셀) 생성 UI 구현                      │
│         │ - 슬라이드형 발송 API 구현                          │
│         │ - 미리보기 기능 구현                                │
│         │ - 전체 통합 테스트                                  │
│         │ - 오류 처리 및 예외 케이스 보완                     │
│         │ - 문서화 및 배포 준비                               │
└─────────┴────────────────────────────────────────────────────┘

================================================================================
7. 테스트 시나리오
================================================================================

7.1 브랜드 연동 테스트
----------------------------------------
1. RCS Biz Center에서 브랜드 승인 완료 확인
2. "솔라피 주식회사" 대행사 지정 완료 확인
3. Chatbot ID, Message Base ID 발급 확인
4. UI에서 브랜드 연동 정보 입력
5. 브랜드 목록에 정상 표시 확인

7.2 템플릿 생성 테스트
----------------------------------------
1. 브랜드 선택 후 템플릿 생성
2. SMS형: 텍스트만 입력 (버튼 1개)
3. LMS형: 긴 텍스트 + 버튼 2개
4. MMS형: 이미지 + 텍스트 + 버튼 2개
5. 슬라이드형: 6개 카드 + 각각 버튼 설정
6. 변수 포함 (#{고객명}, #{상품명} 등)
7. 승인 대기 상태 확인

7.3 메시지 발송 테스트
----------------------------------------
1. 승인된 템플릿 선택
2. 수신자 1명 입력 (실제 번호)
3. 변수값 입력 (고객명, 상품명 등)
4. 미리보기로 최종 메시지 확인
5. 즉시 발송
6. 발송 로그에서 상태 확인 (sent)
7. 실제 휴대폰에서 수신 확인
8. 버튼 클릭 동작 확인

7.4 대량 발송 테스트
----------------------------------------
1. 승인된 템플릿 선택
2. CSV 파일로 수신자 100명 업로드
3. 각 수신자별 변수값 매핑
4. 발송 전 미리보기
5. 발송 시작
6. 발송 진행률 확인
7. 발송 완료 후 성공/실패 건수 확인
8. 잔액 차감 확인

7.5 오류 처리 테스트
----------------------------------------
1. 승인되지 않은 템플릿 발송 시도 → 오류 메시지
2. 잔액 부족 상태에서 발송 시도 → 오류 메시지
3. 잘못된 전화번호 입력 → 개별 실패 처리
4. 네트워크 오류 시뮬레이션 → 재시도 로직
5. 이미지 크기 초과 → 업로드 차단
6. 버튼 3개 이상 추가 시도 → 검증 오류

================================================================================
8. 트러블슈팅 가이드
================================================================================

8.1 브랜드 연동 문제
----------------------------------------
【증상】 브랜드 연동 시 "대행사 지정이 필요합니다" 오류
【해결】
1. RCS Biz Center 로그인
2. 브랜드 관리 → 브랜드 운영 관리
3. "대행사 운영권한 부여" 버튼 클릭
4. "솔라피 주식회사" 검색 후 지정
5. 24시간 후 재시도

【증상】 Chatbot ID를 찾을 수 없음
【해결】
1. 브랜드 대시보드 → 챗봇 관리
2. 챗봇이 없으면 "챗봇 생성" 클릭
3. 챗봇 이름 입력 후 생성
4. 생성된 Chatbot ID 복사

8.2 템플릿 승인 문제
----------------------------------------
【증상】 템플릿이 계속 승인 대기 상태
【해결】
- RCS 템플릿 승인은 RCS Biz Center 관리자가 수동 승인
- 영업일 기준 1-3일 소요
- RCS Biz Center에서 승인 상태 직접 확인
- 반려된 경우 사유 확인 후 수정

【증상】 템플릿 반려 사유: "광고성 문구"
【해결】
- "무료", "할인", "이벤트" 등 광고성 문구 제거
- 정보 제공 위주로 메시지 수정
- 수신거부 안내 문구 추가
- 재신청 후 승인 대기

8.3 발송 실패 문제
----------------------------------------
【증상】 발송 시 "잔액 부족" 오류
【해결】
1. 사용자 잔액 확인
2. 충전 페이지로 이동
3. 필요한 만큼 충전 후 재발송

【증상】 발송 시 "invalid phone number" 오류
【해결】
1. 전화번호 형식 확인 (010-1234-5678 또는 01012345678)
2. 국내 번호만 가능 (010, 011, 016, 017, 018, 019)
3. 하이픈 자동 제거 로직 확인

【증상】 발송은 성공했으나 수신되지 않음
【해결】
- 수신자 단말기가 RCS 지원 기종인지 확인
- RCS 미지원 단말기는 SMS/MMS로 대체 발송 (Fallback)
- 발송 로그에서 실제 발송 채널 확인

8.4 솔라피 API 오류
----------------------------------------
【증상】 "Authentication failed" 오류
【해결】
1. SOLAPI_API_KEY 확인
2. SOLAPI_API_SECRET 확인
3. HMAC 서명 생성 로직 점검
4. 타임스탬프 정확성 확인

【증상】 "Rate limit exceeded" 오류
【해결】
- 솔라피 API 호출 제한 초과
- 1초당 최대 10건 발송 제한
- 대량 발송 시 지연(delay) 추가
- 배치 발송으로 변경

8.5 이미지 업로드 문제
----------------------------------------
【증상】 "파일 크기 초과" 오류
【해결】
- RCS 이미지 최대 1.5MB
- 이미지 압축 후 재업로드
- 권장 크기: 800x600px

【증상】 업로드 후 이미지가 표시되지 않음
【해결】
1. Supabase Storage "rcs-images" 버킷 존재 확인
2. 버킷 Public 정책 설정 확인
3. Public URL 생성 로직 점검
4. CORS 설정 확인

================================================================================
마무리
================================================================================

본 RCS 구현 계획은 다음 순서로 진행됩니다:
1. 카카오 비즈니스 메시지 구현 (KAKAO_IMPLEMENTATION_PLAN.txt)
2. 네이버 톡톡 구현 (NAVER_IMPLEMENTATION_PLAN.txt)
3. RCS 구현 (본 문서) ← 3순위

RCS는 브랜드 승인 기간(1-2주)이 필요하므로, 카카오/네이버 구현과 병행하여
사전 준비(브랜드 개설 신청)를 진행하는 것을 권장합니다.

【참고 자료】
- RCS Biz Center: https://www.rcsbizcenter.com
- 솔라피 문서: https://docs.solapi.com
- RCS 표준 가이드: https://www.gsma.com/futurenetworks/rcs

작성자: Claude Code
최종 업데이트: 2025-10-15
